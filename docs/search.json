[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Series de Tiempo",
    "section": "",
    "text": "Prefacio\nNotas computacionales de clase para el curso CA0415, Series de Tiempo.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "box_jenk.html",
    "href": "box_jenk.html",
    "title": "1  Enfoque de Box-Jenkins",
    "section": "",
    "text": "1.1 Ejemplos de series temporales\nSerie de tiempo de Johnson & Johnson\njj_tibble &lt;- tk_tbl(jj)\njj_tibble %&gt;% \n  ggplot(aes(x = index, y = value)) +\n  geom_line() +\n  labs(x = \"Tiempo\", y = \"Ganancia\")+\n  theme_bw()\nSerie de tiempo de temperaturas globales\ntemp_tibble &lt;- tk_tbl(gtemp_both)\ntemp_tibble %&gt;% \n  ggplot(aes(x = index, y = value)) +\n  geom_line() +\n  labs(x = \"Tiempo\", y = \"Anomalías de Temp.\")+\n  theme_bw()\nSerie de tiempo del índice de Dow Jones:\ndjia_tibble &lt;- tk_tbl(djia)\ndjia_tibble %&gt;% \n  select(index,Close) %&gt;%\n  ggplot(aes(x = index, y = Close)) +\n  geom_line() +\n  labs(x = \"Tiempo\", y = \"Precio de Cierre\")+\n  theme_bw()\nY después de calcular los log-retornos:\ndjiar &lt;- diff(log(djia$Close))[-1]\ndjiar_tibble &lt;- tk_tbl(djiar)\ndjiar_tibble  %&gt;% \n  select(index,Close) %&gt;%\n  ggplot(aes(x = index, y = Close)) +\n  geom_line() +\n  labs(x = \"Tiempo\", y = \"Precio de Cierre\")+\n  theme_bw()\nSerie de tiempo del Niño y la población de peces:\nsoi_tibble &lt;- tk_tbl(soi) %&gt;% rename(soi = value)\n\nsoi_tsibble &lt;- soi_tibble %&gt;% mutate(index = yearmonth(index)) %&gt;%\n  as_tsibble(index = index)\n\nrec_tibble &lt;- tk_tbl(rec) %&gt;% rename(rec = value)\n\nrec_tsibble &lt;- rec_tibble %&gt;% mutate(index = yearmonth(index)) %&gt;%\n  as_tsibble(index = index)\n\nsoi_tsibble %&gt;% \n  ggplot(aes(x = index, y = soi)) +\n  geom_line() +\n  labs(x = \"Tiempo\", y = \"SOI\")+\n  theme_bw()\n\n\n\n\n\n\n\nrec_tsibble %&gt;% \n  ggplot(aes(x = index, y = rec)) +\n  geom_line() +\n  labs(x = \"Tiempo\", y = \"REC\")+\n  theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Enfoque de Box-Jenkins</span>"
    ]
  },
  {
    "objectID": "box_jenk.html#gráficos-de-la-función-de-autocorrelación-estimada.",
    "href": "box_jenk.html#gráficos-de-la-función-de-autocorrelación-estimada.",
    "title": "1  Enfoque de Box-Jenkins",
    "section": "1.2 Gráficos de la función de autocorrelación estimada.",
    "text": "1.2 Gráficos de la función de autocorrelación estimada.\nSiguiendo este último ejemplo, vamos a calcular el ACF de ambas series de SOI y REC:\n\nACF_soi &lt;- soi_tsibble %&gt;% ACF(soi,lag_max = 24)\n\nsoi_tsibble %&gt;% ACF(soi,lag_max = 24) %&gt;%\n  autoplot() +\n  theme_bw()+labs(x = \"Lag\", y = \"ACF\")\n\n\n\n\n\n\n\nrec_tsibble %&gt;% ACF(rec,lag_max = 24) %&gt;%\n  autoplot() +\n  theme_bw()+labs(x = \"Lag\", y = \"ACF\")\n\n\n\n\n\n\n\n\nNoten que en la primera línea del codigo anterior se extrae directamente el ACF de la serie SOI. A continuación el CCF de ambas series:\n\nsoi_rec_tsibble &lt;- soi_tsibble %&gt;% left_join(rec_tsibble,by = \"index\")\n\nsoi_rec_tsibble %&gt;% CCF(x = soi, y = rec, lag_max = 24) %&gt;%\n  autoplot() +\n  theme_bw() +\n  labs(x = \"Lag\", y = \"CCF\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Enfoque de Box-Jenkins</span>"
    ]
  },
  {
    "objectID": "box_jenk.html#análisis-exploratorio-de-series-de-tiempo",
    "href": "box_jenk.html#análisis-exploratorio-de-series-de-tiempo",
    "title": "1  Enfoque de Box-Jenkins",
    "section": "1.3 Análisis exploratorio de series de tiempo",
    "text": "1.3 Análisis exploratorio de series de tiempo\n\n1.3.1 Descomposición de componente trigonométrico:\n\nset.seed(1492)\nnum &lt;- 120\nt &lt;- 1:num\n\nX &lt;- ts(2*cos(2*pi*t/12) + rnorm(120), frequency = 12)\nY &lt;- ts(2*cos(2*pi*(t+5)/12) + rnorm(120), frequency = 12)\n\n\nYw &lt;- resid(lm(Y ~ cos(2*pi*t/12) + sin(2*pi*t/12)))\n\n\nX_df &lt;- data.frame(\n  index = time(X),\n  value = as.numeric(X),\n  series = \"X\"\n)\n\nYw_df &lt;- data.frame(\n  index = time(Y),\n  value = as.numeric(Yw),\n  series = \"Yw\"\n)\n\n\ncombined_df &lt;- bind_rows(X_df, Yw_df)\n\n\ncombined_tsibble &lt;- as_tsibble(combined_df, index = index, key = series)\n\n\nggplot(combined_tsibble, aes(x = index, y = value)) +\n  geom_line() +\n  facet_wrap(~series, scales = \"free_y\") +  # Facet plot with free y-axis scales\n  labs(title = \"Time Series Plot\",\n       x = \"Time\",\n       y = \"Value\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nCon lo cual se compara una de las dos series originales con los residuos después de haberle ajustado un componente triginométrico.\n\n\n1.3.2 Descomposición de tendencia a través de regresión lineal\n\nchicken_tibble &lt;- tk_tbl(chicken)\n\nchicken_tsibble &lt;- as_tsibble(chicken, index = time(chicken)) %&gt;%\n  rename(chicken = value)\n\nfit_pollo &lt;- chicken_tsibble %&gt;%\n  model(lm = TSLM(chicken ~ trend()))\n\nmodel_summary &lt;- glance(fit_pollo)\nprint(model_summary)\n\n# A tibble: 1 × 15\n  .model r_squared adj_r_squared sigma2 statistic  p_value    df log_lik   AIC\n  &lt;chr&gt;      &lt;dbl&gt;         &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 lm         0.917         0.917   22.1     1974. 2.83e-98     2   -533.  561.\n# ℹ 6 more variables: AICc &lt;dbl&gt;, BIC &lt;dbl&gt;, CV &lt;dbl&gt;, deviance &lt;dbl&gt;,\n#   df.residual &lt;int&gt;, rank &lt;int&gt;\n\nmodel_coefficients &lt;- tidy(fit_pollo)\nprint(model_coefficients)\n\n# A tibble: 2 × 6\n  .model term        estimate std.error statistic   p.value\n  &lt;chr&gt;  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 lm     (Intercept)   58.6     0.703        83.3 1.54e-144\n2 lm     trend()        0.299   0.00674      44.4 2.83e- 98\n\nresiduals_df &lt;- augment(fit_pollo) %&gt;%\n  select(index, .resid) %&gt;%\n  rename(residuals = .resid)\n\n\nggplot(residuals_df, aes(x = index, y = residuals)) +\n  geom_line() +\n  labs(title = \"Residuals of the Linear Model\",\n       x = \"Time\",\n       y = \"Residuals\") +\n  theme_minimal()\n\n\n\n\n\n\n\nacf_residuals &lt;- acf(residuals_df$residuals, plot = FALSE)\n\nacf_df &lt;- data.frame(\n  lag = acf_residuals$lag,\n  acf = acf_residuals$acf\n)\n\nggplot(acf_df, aes(x = lag, y = acf)) +\n  geom_bar(stat = \"identity\") +\n  labs(title = \"ACF of Residuals\",\n       x = \"Lag\",\n       y = \"ACF\") +\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Enfoque de Box-Jenkins</span>"
    ]
  },
  {
    "objectID": "cap4.html",
    "href": "cap4.html",
    "title": "2  Capítulo 4",
    "section": "",
    "text": "2.1 Decomposing a Non-Sinusoidal Cycle Using Regression",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capítulo 4</span>"
    ]
  },
  {
    "objectID": "cap4.html#decomposing-a-non-sinusoidal-cycle-using-regression",
    "href": "cap4.html#decomposing-a-non-sinusoidal-cycle-using-regression",
    "title": "2  Capítulo 4",
    "section": "",
    "text": "2.1.1 Introduction\nThis example demonstrates how to decompose a simple dataset into its frequency components using regression. The data given complete one cycle but not in a sinusoidal way, so the first frequency component \\(\\omega_1 = 1/5\\) is expected to be large, while the second component \\(\\omega_2 = 2/5\\) is expected to be small.\n\n\n2.1.2 Data and Frequency Components\nThe dataset ( x = {1, 2, 3, 2, 1} ) is examined with the two frequency components. We use cosines and sines at the relevant frequencies to perform the decomposition.\n\n# Define the dataset\nx = c(1, 2, 3, 2, 1)\n\n# Define cosine and sine terms for the first and second frequency components\nc1 = cos(2 * pi * 1:5 * 1/5)\ns1 = sin(2 * pi * 1:5 * 1/5)\nc2 = cos(2 * pi * 1:5 * 2/5)\ns2 = sin(2 * pi * 1:5 * 2/5)\n\n# Combine the components into matrices for regression\nomega1 = cbind(c1, s1)\nomega2 = cbind(c2, s2)\nanova(lm(x~omega1+omega2))\n\nWarning in anova.lm(lm(x ~ omega1 + omega2)): ANOVA F-tests on an essentially\nperfect fit are unreliable\n\n\nAnalysis of Variance Table\n\nResponse: x\n          Df  Sum Sq Mean Sq F value Pr(&gt;F)\nomega1     2 2.74164 1.37082     NaN    NaN\nomega2     2 0.05836 0.02918     NaN    NaN\nResiduals  0 0.00000     NaN               \n\n\nThis analysis presents the periodograms of the SOI and Recruitment series. It explores the significance of certain periodicities, particularly the yearly cycle and a potential four-year El Niño cycle. Confidence intervals for these spectral peaks are also calculated, but the results show wide intervals, making it difficult to assert the significance of the four-year cycle. The periodograms for the SOI and Recruitment series show: - A narrow-band peak at the yearly cycle ( \\(\\omega = 1/12\\) ). - A wide-band peak centered around the four-year cycle ( \\(\\omega = 1/48\\) ), possibly linked to El Niño.\n\n### R Code to Reproduce the Periodogram\n# Load the astsa package\nlibrary(astsa)\n\n# Set up plotting parameters\npar(mfrow=c(2,1))\n\n# Compute and plot the periodogram for the SOI series\nsoi.per = mvspec(soi, log=\"no\")\nabline(v=1/4, lty=2) # Add a vertical line at the four-year cycle\n\n# Compute and plot the periodogram for the Recruitment series\nrec.per = mvspec(rec, log=\"no\")\nabline(v=1/4, lty=2)\n\n\n\n\n\n\n\n\nConfidence Intervals for Spectral Estimates\nWe compute approximate 95% confidence intervals for the spectrum at the yearly cycle \\(\\omega=1/12\\), and the possible four-year cycle \\(\\omega = 1/48\\).\n\n# Confidence interval boundaries\nU = qchisq(.025, 2)  # 0.05063\nL = qchisq(.975, 2)  # 7.37775\n\n# SOI periodogram values at specific frequencies\nsoi_per_1_12 = soi.per$spec[40] # SOI periodogram at freq 1/12 = 40/480\nsoi_per_1_48 = soi.per$spec[10] # SOI periodogram at freq 1/48 = 10/480\n\n# Confidence intervals for the yearly cycle\nCI_1_12 = c(2 * soi_per_1_12 / L, 2 * soi_per_1_12 / U) \nCI_1_12 # Approximate 95% CI for the yearly cycle\n\n[1]  0.2635573 38.4010800\n\n# Confidence intervals for the four-year cycle\nCI_1_48 = c(2 * soi_per_1_48 / L, 2 * soi_per_1_48 / U) \nCI_1_48 # Approximate 95% CI for the four-year cycle\n\n[1] 0.0145653 2.1222066\n\n\nInterpretation\n\nThe periodogram at the yearly cycle \\(\\omega = 1/12\\) is significant, with a 95% confidence interval that suggests its importance in the SOI series.\nThe wide confidence interval at \\(\\omega= 1/48\\) (representing the four-year cycle) indicates that this peak may not be significant.\n\nConclusion\nThe periodogram analysis suggests the presence of a strong yearly cycle and a possible but irregular four-year cycle, which could be linked to El Niño. Further analysis is required to refine these findings.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capítulo 4</span>"
    ]
  },
  {
    "objectID": "cap4.html#smoothing-the-periodogram",
    "href": "cap4.html#smoothing-the-periodogram",
    "title": "2  Capítulo 4",
    "section": "2.2 Smoothing the Periodogram",
    "text": "2.2 Smoothing the Periodogram\nThis example shows the smoothed periodogram for the SOI and Recruitment series, using a Daniell kernel to average the periodograms computed earlier. The goal is to reduce noise in the spectrum while maintaining key features, particularly the El Niño frequency. The smoothed spectra help in identifying the predominant periods and their significance.\n\n2.2.1 Averaged Periodogram Calculation\nThe Daniell kernel is used with ( L = 9 ) to compute the averaged periodograms. This provides a balance between noise reduction and retaining important peaks, as shown in the R code below.\n\n# Compute and plot the averaged periodogram for SOI\nsoi.ave = mvspec(soi, kernel('daniell', 4), log='no')\n\nBandwidth: 0.225 \nDegrees of Freedom: 16.99 \n\nabline(v=c(.25, 1, 2, 3), lty=2) # Add vertical lines at key frequencies\n\n\n\n\n\n\n\n# Display bandwidth of the SOI periodogram\nsoi.ave$bandwidth\n\n[1] 0.225\n\n# Bandwidth is 0.225, adjusted for the frequency scale in cycles per year\n\n# Compute and plot the averaged periodogram for Recruitment series\nrec.ave = mvspec(rec, kernel('daniell', 4), log='no')\n\nBandwidth: 0.225 \nDegrees of Freedom: 16.99 \n\nabline(v=c(.25, 1, 2, 3), lty=2) # Add vertical lines at key frequencies\n\n\n\n\n\n\n\n\nConfidence Intervals for Spectral Peaks\nWe compute 95% confidence intervals for the SOI spectrum at key frequencies, such as the El Niño cycle (48 months) and the yearly cycle.\n\n# Degrees of freedom for the averaged periodogram\ndf = soi.ave$df\ndf # Returned value: 16.9875\n\n[1] 16.9875\n\n# Compute chi-squared limits\nU = qchisq(.025, df)  # Upper limit\nL = qchisq(.975, df)  # Lower limit\n\n# Spectrum values at key frequencies\nsoi_spec_1_48 = soi.ave$spec[10]  # Spectrum at frequency 1/48\nsoi_spec_1_12 = soi.ave$spec[40]  # Spectrum at frequency 1/12\n\n# Confidence intervals for the 48-month (El Niño) cycle\nCI_1_48 = c(df * soi_spec_1_48 / L, df * soi_spec_1_48 / U)\nCI_1_48 # Approximate 95% confidence interval for 1/48\n\n[1] 0.02787891 0.11133335\n\n# Confidence intervals for the yearly cycle (1/12)\nCI_1_12 = c(df * soi_spec_1_12 / L, df * soi_spec_1_12 / U)\nCI_1_12 # Approximate 95% confidence interval for 1/12\n\n[1] 0.06703963 0.26772011\n\n\nInterpretation\nThe smoothed spectra highlight the El Niño frequency and the yearly cycle more clearly:\n\nAt \\(\\omega=1/12\\) (yearly cycle), the smoothing slightly flattens and spreads the peak. Harmonics of the yearly cycle appear at frequencies like \\(\\omega=1\\Delta,2\\Delta,\\cdots\\).\nConfidence intervals suggest that the El Niño frequency (48 months) shows significant power, with lower limits exceeding baseline spectral levels, confirming its importance in the SOI and Recruitment series.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capítulo 4</span>"
    ]
  },
  {
    "objectID": "cap4.html#introduction-1",
    "href": "cap4.html#introduction-1",
    "title": "2  Capítulo 4",
    "section": "2.3 Introduction",
    "text": "2.3 Introduction\nThis example shows how to estimate the spectra of the SOI and Recruitment series using a smoothed periodogram. A modified Daniell kernel with ( m = 3 ) is applied, and the periodogram is smoothed twice. The resulting estimates are considered more visually appealing than those in previous examples.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capítulo 4</span>"
    ]
  },
  {
    "objectID": "cap4.html#smoothing-the-periodogram-with-a-modified-daniell-kernel",
    "href": "cap4.html#smoothing-the-periodogram-with-a-modified-daniell-kernel",
    "title": "2  Capítulo 4",
    "section": "2.4 Smoothing the Periodogram with a Modified Daniell Kernel",
    "text": "2.4 Smoothing the Periodogram with a Modified Daniell Kernel\nWe use the Daniell kernel, smoothed with ( m = 3 ), to estimate the spectra. The kernel coefficients are shown below.\n\n# Define and plot the modified Daniell kernel with m = 3\nk = kernel(\"modified.daniell\", c(3, 3))\n\n# Display the kernel coefficients\nk$coef\n\n[1] 0.152777778 0.138888889 0.111111111 0.083333333 0.055555556 0.027777778\n[7] 0.006944444\n\n# Plot the kernel\nplot(k)\n\n\n\n\n\n\n\n\nEstimating the Spectra for the SOI Series\nWe now apply the smoothed kernel to the SOI series, plot the periodogram, and calculate the bandwidth and degrees of freedom.\n\n# Calculate and plot the smoothed periodogram for the SOI series\nsoi.smo = mvspec(soi, kernel=k, taper=.1, log=\"no\")\n\nBandwidth: 0.231 \nDegrees of Freedom: 15.61 \n\nabline(v=c(.25, 1), lty=2) # Add vertical lines at key frequencies\n\n\n\n\n\n\n\n# Retrieve degrees of freedom and bandwidth\ndf_soi = soi.smo$df\nbandwidth_soi = soi.smo$bandwidth\n\nsoi.smo$spec[soi.smo$freq==1]\n\n[1] 0.1675368\n\ndf_soi*soi.smo$spec[soi.smo$freq==1]/qchisq(0.975,df = df_soi)\n\n[1] 0.09235481\n\ndf_soi*soi.smo$spec[soi.smo$freq==1]/qchisq(0.025,df = df_soi)\n\n[1] 0.3929982\n\n# Display degrees of freedom and bandwidth\ndf_soi  # Degrees of freedom: 17.42618\n\n[1] 15.61029\n\nbandwidth_soi  # Bandwidth: 0.2308103\n\n[1] 0.2308103\n\n\nEstimating the Spectra for the Recruitment Series\nWe repeat the above steps for the Recruitment series.\n\n# Calculate and plot the smoothed periodogram for the Recruitment series\nrec.smo = mvspec(rec, kernel=k, taper=.1, log=\"no\")\n\nBandwidth: 0.231 \nDegrees of Freedom: 15.61 \n\nabline(v=c(.25, 1), lty=2) # Add vertical lines at key frequencies\n\n\n\n\n\n\n\n# Retrieve degrees of freedom and bandwidth\ndf_rec = rec.smo$df\nbandwidth_rec = rec.smo$bandwidth\n\n# Display degrees of freedom and bandwidth\ndf_rec  # Degrees of freedom: same as SOI\n\n[1] 15.61029\n\nbandwidth_rec  # Bandwidth: same as SOI\n\n[1] 0.2308103",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capítulo 4</span>"
    ]
  },
  {
    "objectID": "cap4.html#smoothed-periodogram-for-soi-and-recruitment-series",
    "href": "cap4.html#smoothed-periodogram-for-soi-and-recruitment-series",
    "title": "2  Capítulo 4",
    "section": "2.5 Smoothed Periodogram for SOI and Recruitment Series",
    "text": "2.5 Smoothed Periodogram for SOI and Recruitment Series\n\n2.5.1 Introduction\nThis example shows how to estimate the spectra of the SOI and Recruitment series using a smoothed periodogram with a modified Daniell kernel. The kernel is smoothed twice with ( m = 3 ), yielding ( \\(L = 2m + 1 = 7\\) ). The bandwidth and degrees of freedom are calculated, and a taper of 10% is applied to reduce leakage effects.\n\n\n2.5.2 Defining the Modified Daniell Kernel\nThe modified Daniell kernel is created and its coefficients are displayed. This kernel is used to smooth the periodogram.\n\n# Define and plot the modified Daniell kernel with m = 3\nk = kernel(\"modified.daniell\", c(3, 3))\n\n# Display the kernel coefficients\nk$coef\n\n[1] 0.152777778 0.138888889 0.111111111 0.083333333 0.055555556 0.027777778\n[7] 0.006944444\n\n# Plot the kernel\nplot(k)\n\n\n\n\n\n\n\n\n\n\n2.5.3 Smoothed Spectral Estimate for SOI\nThe smoothed periodogram for the SOI series is calculated, applying a 10% taper to reduce spectral leakage. The degrees of freedom and bandwidth are then retrieved.\n\n# Calculate and plot the smoothed periodogram for the SOI series\nsoi.smo = mvspec(soi, kernel=k, taper=.1, log=\"no\")\n\nBandwidth: 0.231 \nDegrees of Freedom: 15.61 \n\nabline(v=c(.25, 1), lty=2) # Add vertical lines at key frequencies\n\n\n\n\n\n\n\n# Retrieve degrees of freedom and bandwidth\ndf_soi = soi.smo$df\nbandwidth_soi = soi.smo$bandwidth\n\n# Display degrees of freedom and bandwidth\ndf_soi  # Degrees of freedom: 17.42618\n\n[1] 15.61029\n\nbandwidth_soi  # Bandwidth: 0.2308103\n\n[1] 0.2308103\n\n\n\n\n2.5.4 Smoothed Spectral Estimate for Recruitment\nWe repeat the steps for the Recruitment series.\n\n# Calculate and plot the smoothed periodogram for the Recruitment series\nrec.smo = mvspec(rec, kernel=k, taper=.1, log=\"no\")\n\nBandwidth: 0.231 \nDegrees of Freedom: 15.61 \n\nabline(v=c(.25, 1), lty=2) # Add vertical lines at key frequencies\n\n\n\n\n\n\n\n# Retrieve degrees of freedom and bandwidth\ndf_rec = rec.smo$df\nbandwidth_rec = rec.smo$bandwidth\n\n# Display degrees of freedom and bandwidth\ndf_rec  # Degrees of freedom: same as SOI\n\n[1] 15.61029\n\nbandwidth_rec  # Bandwidth: same as SOI\n\n[1] 0.2308103\n\n\n\n\n2.5.5 Alternative Method for Estimation\nAn alternative way to generate the smoothed periodogram is by using the spans argument instead of explicitly defining the Daniell kernel. The spans vector specifies the smoothing parameter in terms of \\(L=2m+1\\), where \\(m=3\\).\n\n# Alternative method using spans to define the smoothing parameter\nsoi.smo_alt = mvspec(soi, taper=.1, spans=c(7, 7))\n\nBandwidth: 0.231 \nDegrees of Freedom: 15.61",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capítulo 4</span>"
    ]
  },
  {
    "objectID": "cap4.html#the-effect-of-tapering-on-the-soi-series",
    "href": "cap4.html#the-effect-of-tapering-on-the-soi-series",
    "title": "2  Capítulo 4",
    "section": "2.6 The Effect of Tapering on the SOI Series",
    "text": "2.6 The Effect of Tapering on the SOI Series\n\n2.6.1 Introduction\nIn this example, we examine how tapering affects the spectral estimate of the SOI series. Tapering helps mitigate the effect of spectral leakage, which can blur periodic signals in the data. We compare the spectrum with no tapering against a spectrum with full tapering (50%). The fully tapered spectrum better distinguishes between the yearly cycle ($= 1 \\() and the El Niño cycle (\\) = 1/4 $).\n\n\n2.6.2 Spectral Estimation with and without Tapering\nWe calculate the spectral estimate of the SOI series twice: once with no tapering and once with full tapering (50%).\n\n# Calculate the spectrum with no tapering\ns0 = mvspec(soi, spans=c(7, 7), plot=FALSE) # No taper\n\n# Calculate the spectrum with full tapering (50%)\ns50 = mvspec(soi, spans=c(7, 7), taper=.5, plot=FALSE) # Full taper\n\n\n\n2.6.3 Plotting the Spectral Estimates\nWe now plot the spectral estimates on a log scale, using a solid line for the fully tapered spectrum and a dashed line for the non-tapered spectrum.\n\n# Plot the fully tapered spectrum (solid line)\nplot(s50$freq, s50$spec, log=\"y\", type=\"l\", ylab=\"Spectrum\", xlab=\"Frequency\")\n\n# Add the non-tapered spectrum (dashed line)\nlines(s0$freq, s0$spec, lty=2) # Dashed line for no taper\n\n\n\n\n\n\n\n\n\n\n2.6.4 Interpretation\nFrom the plot, we observe that tapering (solid line) leads to better separation between the yearly cycle (\\(\\omega=1\\)) and the El Niño cycle (\\(\\omega=1/4\\)). The non-tapered spectrum (dashed line) shows more spectral leakage, blurring these two important periodic components. By applying a taper, we reduce this leakage and obtain a clearer picture of the underlying spectral features.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capítulo 4</span>"
    ]
  }
]